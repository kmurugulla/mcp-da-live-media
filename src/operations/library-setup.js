// src/operations/library-setup.js

import { z } from 'zod';
import { createGitHubClient } from '../common/gh-utils.js';
import { daAdminRequest, formatURL, uploadHTML, uploadJSON } from '../common/utils.js';
import {
  buildLibraryPath,
  buildContentUrl,
  getDataSheet,
  getOptionsSheet,
  createLibraryJSON,
  addEntry
} from '../common/library-cfg-utils.js';
import { validatePrerequisites } from '../common/validation-utils.js';
import { generateBlockTemplate, extractBlockContent } from './blocks.js';
import { LIBRARY_TYPES } from '../common/global.js';
import { registerLibraryType } from './config.js';

const AddBlockSchema = z.object({
  org: z.string().describe('The organization name'),
  repo: z.string().describe('The repository name'),
  blockName: z.string().describe('The block name to add'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  branch: z.string().optional().default('main').describe('GitHub branch name (default: main)'),
  blocksPath: z.string().optional().default('blocks').describe('Path to blocks folder (default: blocks, e.g., aemedge/blocks)'),
  description: z.string().optional().describe('Optional description for Library Metadata'),
  sourceDocument: z.string().optional().describe('Optional path to source document with real block content (e.g., /ue-editor/demo)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

const SetupSchema = z.object({
  org: z.string().describe('The organization name'),
  repo: z.string().describe('The repository name'),
  baseFolder: z.string().optional().default('library').describe('Base folder for library (default: library)'),
  branch: z.string().optional().default('main').describe('GitHub branch name (default: main)'),
  blocksPath: z.string().optional().default('blocks').describe('Path to blocks folder (default: blocks, e.g., aemedge/blocks)'),
  filter: z.string().optional().describe('Optional regex pattern to filter block names'),
  sourceDocument: z.string().optional().describe('Optional path to source document with real block content for all blocks (e.g., /ue-editor/demo)'),
  autoGenerateDocs: z.boolean().optional().default(true).describe('Automatically generate documentation for blocks (default: true)'),
  preserveExisting: z.boolean().optional().default(true).describe('Preserve existing documentation (default: true)'),
  preview: z.boolean().optional().default(false).describe('Preview mode - show plan without executing (default: false)')
});

function decodeBase64Content(base64Content) {
  return Buffer.from(base64Content, 'base64').toString('utf-8');
}

function buildBlockFilePath(blocksPath, blockName, fileName) {
  return `${blocksPath}/${blockName}/${fileName}`;
}

function createBlockEntry(blockName, baseFolder, org, repo) {
  const displayName = blockName.charAt(0).toUpperCase() + blockName.slice(1);
  const blockPath = buildContentUrl(org, repo, `${baseFolder}/blocks/${blockName}`);
  return { name: displayName, path: blockPath };
}

async function uploadHTMLContent(org, repo, path, htmlContent) {
  const url = formatURL('source', org, repo, path, 'html');
  return uploadHTML(url, htmlContent);
}

async function uploadJSONContent(org, repo, path, jsonData) {
  const url = formatURL('source', org, repo, path, 'json');
  return uploadJSON(url, jsonData);
}

async function getFileContent(octokit, org, repo, path, branch) {
  try {
    const response = await octokit.repos.getContent({ owner: org, repo, path, ref: branch });
    return decodeBase64Content(response.data.content);
  } catch {
    return null;
  }
}

async function analyzeBlockVariants(octokit, org, repo, blockName, blocksPath, branch) {
  const variants = [];
  let description = null;

  const cssContent = await getFileContent(octokit, org, repo, buildBlockFilePath(blocksPath, blockName, `${blockName}.css`), branch);
  if (cssContent) {
    const variantPattern = new RegExp(`\\.${blockName}\\.(\\w+)`, 'g');
    const variantMatches = cssContent.matchAll(variantPattern);
    const variantSet = new Set();
    for (const match of variantMatches) {
      if (match[1] !== blockName) {
        variantSet.add(match[1]);
      }
    }
    variants.push(...Array.from(variantSet));
  }

  const jsContent = await getFileContent(octokit, org, repo, buildBlockFilePath(blocksPath, blockName, `${blockName}.js`), branch);
  if (jsContent) {
    const jsdocMatch = jsContent.match(/\/\*\*\s*\n\s*\*\s*(.+?)\s*\n/);
    if (jsdocMatch) {
      description = jsdocMatch[1];
    }
  }

  return { variants, description };
}

async function createBlockDoc(org, repo, docPath, blockName, variants, description, blockContent = null) {
  const template = generateBlockTemplate(blockName, description, variants, {}, blockContent);
  await uploadHTMLContent(org, repo, docPath, template);
  return buildContentUrl(org, repo, docPath);
}

async function checkBlockFiles(octokit, org, repo, blockName, blocksPath, branch) {
  try {
    const response = await octokit.repos.getContent({
      owner: org,
      repo,
      path: `${blocksPath}/${blockName}`,
      ref: branch
    });
    
    const files = Array.isArray(response.data) ? response.data : [response.data];
    return files.filter(f => f.type === 'file' && (f.name.endsWith('.js') || f.name.endsWith('.css')));
  } catch {
    return [];
  }
}

async function checkDocExists(org, repo, docPath) {
  try {
    const url = formatURL('source', org, repo, docPath, 'html');
    await daAdminRequest(url);
    return true;
  } catch {
    return false;
  }
}

async function getExistingBlocksConfig(org, repo, baseFolder) {
  try {
    const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
    const url = formatURL('source', org, repo, configPath, 'json');
    return await daAdminRequest(url);
  } catch {
    return null;
  }
}

async function updateBlocksConfig(org, repo, baseFolder, entries) {
  const configPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder);
  const blocksJSON = await getExistingBlocksConfig(org, repo, baseFolder);

  let dataSheet = getDataSheet(blocksJSON);
  const optionsSheet = getOptionsSheet(blocksJSON);

  for (const entry of entries) {
    dataSheet = addEntry(dataSheet, entry);
  }

  const newBlocksJSON = createLibraryJSON(LIBRARY_TYPES.BLOCKS, dataSheet.data, optionsSheet);
  await uploadJSONContent(org, repo, configPath, newBlocksJSON);

  return {
    configPath,
    optionsPreserved: !!optionsSheet
  };
}

async function processBlockDocumentation(octokit, org, repo, blockName, blocksPath, baseFolder, branch, description, sourceDocument, docExists, preview) {
  if (docExists) {
    return {
      step: 4,
      action: 'Preserving existing documentation',
      status: 'completed',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      created: false
    };
  }

  if (preview) {
    return {
      step: 4,
      action: 'Would create documentation',
      status: 'planned',
      docPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName),
      docUrl: buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName)),
      sourceDocument: sourceDocument || null
    };
  }

  const analysis = await analyzeBlockVariants(octokit, org, repo, blockName, blocksPath, branch);
  const finalDescription = description || analysis.description;
  const blockContent = await extractBlockContent(org, repo, sourceDocument, blockName);
  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = await createBlockDoc(org, repo, docPath, blockName, analysis.variants, finalDescription, blockContent);

  return {
    step: 4,
    action: 'Creating block documentation',
    status: 'completed',
    created: true,
    docPath,
    docUrl,
    usedSourceContent: !!blockContent
  };
}

async function addBlock(args) {
  const { org, repo, blockName, baseFolder, branch, blocksPath, description, sourceDocument, preview } = args;
  const octokit = createGitHubClient();

  const result = {
    blockName,
    baseFolder,
    preview,
    steps: [],
    errors: []
  };

  try {
    result.steps.push({ step: 1, action: 'Validating prerequisites', status: 'in_progress' });

    const validation = await validatePrerequisites(octokit, org, repo, baseFolder, blockName, branch);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
      result.steps[0].status = 'failed';
      result.steps[0].errors = validation.errors;
      return result;
    }
    result.steps[0].status = 'completed';

    result.steps.push({ step: 2, action: `Checking if block '${blockName}' exists in GitHub`, status: 'in_progress' });

    try {
      await octokit.repos.getContent({
        owner: org,
        repo,
        path: `${blocksPath}/${blockName}`,
        ref: branch
      });
      result.steps[1].status = 'completed';
      result.steps[1].exists = true;
    } catch {
      result.errors.push(`Block '${blockName}' not found in GitHub repository ${org}/${repo}/${blocksPath}`);
      result.steps[1].status = 'failed';
      result.steps[1].error = 'Block not found in GitHub';
      return result;
    }

    const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
    const docUrl = buildContentUrl(org, repo, docPath);

    result.steps.push({ step: 3, action: 'Checking if block documentation exists', status: 'in_progress' });
    const docExists = await checkDocExists(org, repo, docPath);
    result.steps[2].status = 'completed';
    result.steps[2].exists = docExists;
    result.steps[2].path = docPath;
    result.steps[2].url = docUrl;

    if (preview) {
      result.steps.push({
        step: 4,
        action: docExists ? 'Would preserve existing documentation' : 'Would create documentation',
        status: 'planned',
        docPath,
        docUrl,
        sourceDocument: sourceDocument || null
      });

      result.steps.push({
        step: 5,
        action: 'Would add block to blocks.json',
        status: 'planned',
        configPath: buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder)
      });

      result.steps.push({
        step: 6,
        action: 'Would register in site config library sheet',
        status: 'planned',
        libraryType: 'Blocks'
      });

      return result;
    }

    const docStep = await processBlockDocumentation(
      octokit, org, repo, blockName, blocksPath, baseFolder, branch, description, sourceDocument, docExists, preview
    );
    result.steps.push(docStep);

    result.steps.push({ step: 5, action: 'Adding block to blocks.json', status: 'in_progress' });

    const entry = createBlockEntry(blockName, baseFolder, org, repo);
    const configResult = await updateBlocksConfig(org, repo, baseFolder, [entry]);

    result.steps[4].status = 'completed';
    result.steps[4].configPath = configResult.configPath;
    result.steps[4].optionsPreserved = configResult.optionsPreserved;
    result.steps[4].entry = entry;

    result.steps.push({ step: 6, action: 'Registering in site config library sheet', status: 'in_progress' });

    const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
    const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);

    result.steps[5].status = 'completed';
    result.steps[5].registered = regResult.registered;
    result.steps[5].librarySheet = {
      existed: !regResult.createdSheet,
      entryCount: regResult.libraryEntryCount
    };

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

async function processBlock(octokit, org, repo, blockName, blocksPath, baseFolder, branch, sourceDocument, autoGenerateDocs, preserveExisting, preview) {
  const blockResult = {
    name: blockName,
    action: 'unknown',
    docPath: null,
    docUrl: null,
    error: null
  };

  const blockFiles = await checkBlockFiles(octokit, org, repo, blockName, blocksPath, branch);

  if (blockFiles.length === 0) {
    blockResult.action = 'skipped';
    blockResult.error = 'No .js or .css files found';
    return blockResult;
  }

  const docPath = buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder, blockName);
  const docUrl = buildContentUrl(org, repo, docPath);

  blockResult.docPath = docPath;
  blockResult.docUrl = docUrl;

  const docExists = await checkDocExists(org, repo, docPath);

  if (docExists && preserveExisting) {
    blockResult.action = 'preserved';
  } else if (autoGenerateDocs) {
    if (preview) {
      blockResult.action = docExists ? 'would_update' : 'would_create';
    } else {
      const analysis = await analyzeBlockVariants(octokit, org, repo, blockName, blocksPath, branch);
      const blockContent = await extractBlockContent(org, repo, sourceDocument, blockName);
      await createBlockDoc(org, repo, docPath, blockName, analysis.variants, analysis.description, blockContent);
      blockResult.action = docExists ? 'updated' : 'created';
      blockResult.usedSourceContent = !!blockContent;
    }
  } else {
    blockResult.action = 'skipped';
  }

  return blockResult;
}

async function setup(args) {
  const { org, repo, baseFolder, branch, blocksPath, filter, sourceDocument, autoGenerateDocs, preserveExisting, preview } = args;
  const octokit = createGitHubClient();

  const result = {
    baseFolder,
    branch,
    blocksPath,
    sourceDocument: sourceDocument || null,
    preview,
    summary: {
      totalBlocks: 0,
      docsCreated: 0,
      docsUpdated: 0,
      docsPreserved: 0,
      docsSkipped: 0,
      configUpdated: false
    },
    blocks: [],
    errors: []
  };

  try {
    const validation = await validatePrerequisites(octokit, org, repo, baseFolder, null, branch);
    if (!validation.valid) {
      result.errors.push(...validation.errors);
      return result;
    }

    const response = await octokit.repos.getContent({
      owner: org,
      repo,
      path: blocksPath || 'blocks',
      ref: branch
    });

    const contents = Array.isArray(response.data) ? response.data : [response.data];
    let directories = contents.filter(item => item.type === 'dir');

    if (filter) {
      const filterRegex = new RegExp(filter);
      directories = directories.filter(dir => filterRegex.test(dir.name));
    }

    result.summary.totalBlocks = directories.length;

    for (const dir of directories) {
      try {
        const blockResult = await processBlock(
          octokit, org, repo, dir.name, blocksPath, baseFolder, branch, sourceDocument,
          autoGenerateDocs, preserveExisting, preview
        );

        if (blockResult.action === 'created') {
          result.summary.docsCreated++;
        } else if (blockResult.action === 'updated') {
          result.summary.docsUpdated++;
        } else if (blockResult.action === 'preserved') {
          result.summary.docsPreserved++;
        } else if (blockResult.action === 'skipped') {
          result.summary.docsSkipped++;
        }

        result.blocks.push(blockResult);

      } catch (error) {
        result.blocks.push({
          name: dir.name,
          action: 'error',
          docPath: null,
          docUrl: null,
          error: error.message
        });
        result.errors.push(`Block ${dir.name}: ${error.message}`);
      }
    }

    if (!preview) {
      const entries = result.blocks
        .filter(block => block.action === 'created' || block.action === 'updated' || block.action === 'preserved')
        .map(block => createBlockEntry(block.name, baseFolder, org, repo));

      if (entries.length > 0) {
        const configResult = await updateBlocksConfig(org, repo, baseFolder, entries);
        result.summary.configUpdated = true;
        result.configPath = configResult.configPath;

        const configPath = `${buildContentUrl(org, repo, buildLibraryPath(LIBRARY_TYPES.BLOCKS, baseFolder))}.json`;
        const regResult = await registerLibraryType(org, repo, 'Blocks', configPath);
        result.siteConfigRegistered = regResult.registered;
        result.librarySheet = {
          existed: !regResult.createdSheet,
          entryCount: regResult.libraryEntryCount
        };
      }
    }

    result.success = true;
    return result;

  } catch (error) {
    result.errors.push(error.message);
    result.success = false;
    return result;
  }
}

export const tools = [
  {
    name: 'da_library_add_block',
    description: 'Add a single block to the library. Complete workflow: validates access, creates documentation if needed, and updates blocks.json. Use preview=true to see what would be done.',
    schema: AddBlockSchema,
    handler: async (args) => addBlock(args)
  },
  {
    name: 'da_library_setup',
    description: 'Batch setup entire library. Discovers all blocks from GitHub, creates documentation, and updates blocks.json. Use preview=true to see what would be done.',
    schema: SetupSchema,
    handler: async (args) => setup(args)
  }
];
